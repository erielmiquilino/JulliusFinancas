name: Deploy .NET API

on:
  push:
    branches:
      - main
    paths:
      - 'server/**'
      - '.github/workflows/deploy-dotnet.yml'
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

env:
  DOTNET_VERSION: '9.0.x'
  API_PROJECT_PATH: './server/src/Jullius.ServiceApi'
  OUTPUT_PATH: './output'
  AZURE_RESOURCE_GROUP: 'rg-jullius-prod'

jobs:
  build-and-deploy:
    name: Build and Deploy .NET API
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: Cache NuGet packages
      uses: actions/cache@v3
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }}
        restore-keys: |
          ${{ runner.os }}-nuget-

    - name: Restore dependencies
      working-directory: ${{ env.API_PROJECT_PATH }}
      run: dotnet restore

    - name: Run tests
      working-directory: ./server/src
      run: |
        # Procura por projetos de teste e executa
        find . -name "*.Tests.csproj" -o -name "*.Test.csproj" | while read testproject; do
          echo "Running tests for $testproject"
          dotnet test "$testproject" --no-restore --verbosity normal --logger trx --results-directory ./TestResults
        done
      continue-on-error: true

    - name: Build application
      working-directory: ${{ env.API_PROJECT_PATH }}
      run: |
        dotnet build --configuration Release --no-restore
        dotnet publish --configuration Release --output ${{ env.OUTPUT_PATH }} --no-build

    - name: Create deployment package
      run: |
        cd ${{ env.API_PROJECT_PATH }}/${{ env.OUTPUT_PATH }}
        zip -r ${{ github.workspace }}/deployment-package.zip .
        cd ${{ github.workspace }}
        ls -la deployment-package.zip

    - name: Azure Login via OIDC
      uses: azure/login@v2
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    - name: Get Web App name
      id: get-webapp-name
      run: |
        # Lista todos os web apps no resource group
        WEBAPP_NAME=$(az webapp list \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --query "[?kind=='app,linux' && contains(name, 'jullius-api')].name" \
          --output tsv | head -n 1)
        
        if [ -z "$WEBAPP_NAME" ]; then
          echo "‚ùå Web App n√£o encontrado no Resource Group: ${{ env.AZURE_RESOURCE_GROUP }}"
          exit 1
        fi
        
        echo "WEBAPP_NAME=$WEBAPP_NAME" >> $GITHUB_OUTPUT
        echo "‚úÖ Web App encontrado: $WEBAPP_NAME"

    - name: Deploy to Azure Web App
      run: |
        az webapp deploy \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --name ${{ steps.get-webapp-name.outputs.WEBAPP_NAME }} \
          --src-path ./deployment-package.zip \
          --type zip \
          --async true

    - name: Wait for deployment and verify health
      run: |
        echo "‚è≥ Aguardando deployment e inicializa√ß√£o da aplica√ß√£o..."
        
        # Obt√©m a URL do Web App
        WEBAPP_URL=$(az webapp show \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --name ${{ steps.get-webapp-name.outputs.WEBAPP_NAME }} \
          --query defaultHostName --output tsv)
        
        echo "üîç Verificando sa√∫de da aplica√ß√£o em: https://$WEBAPP_URL"
        
        # Primeiro verifica se a aplica√ß√£o est√° rodando (endpoint /startup)
        echo "1Ô∏è‚É£ Verificando se a aplica√ß√£o iniciou..."
        MAX_ATTEMPTS_STARTUP=30  # 30 tentativas x 20 segundos = 10 minutos
        ATTEMPT=1
        STARTUP_OK=false
        
        while [ $ATTEMPT -le $MAX_ATTEMPTS_STARTUP ]; do
          echo "Tentativa $ATTEMPT/$MAX_ATTEMPTS_STARTUP - Aguardando 20 segundos..."
          sleep 20
          
          # Testa o endpoint de startup
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 https://$WEBAPP_URL/startup || echo "000")
          
          if [ "$HTTP_CODE" = "200" ]; then
            echo "‚úÖ Aplica√ß√£o iniciada com sucesso! (HTTP $HTTP_CODE)"
            STARTUP_OK=true
            break
          elif [ "$HTTP_CODE" = "000" ]; then
            echo "‚è≥ Aplica√ß√£o ainda n√£o est√° respondendo (timeout/connection error)"
          else
            echo "‚ö†Ô∏è Aplica√ß√£o retornou HTTP $HTTP_CODE no endpoint /startup"
          fi
          
          ATTEMPT=$((ATTEMPT + 1))
        done
        
        if [ "$STARTUP_OK" = "false" ]; then
          echo "‚ùå Aplica√ß√£o n√£o iniciou ap√≥s 10 minutos."
          az webapp show \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ steps.get-webapp-name.outputs.WEBAPP_NAME }} \
            --query "{state: state, availabilityState: availabilityState}" \
            --output table
          exit 1
        fi
        
        # Agora verifica o health check (banco de dados)
        echo "2Ô∏è‚É£ Verificando conex√£o com banco de dados (Azure SQL Serverless)..."
        
        # Primeiro tenta despertar o banco
        echo "üîå Tentando despertar o Azure SQL Serverless..."
        for i in {1..3}; do
          WAKEUP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 60 https://$WEBAPP_URL/wakeup-db || echo "000")
          if [ "$WAKEUP_CODE" = "200" ]; then
            echo "‚úÖ Banco despertado com sucesso!"
            break
          else
            echo "‚è≥ Tentativa $i de despertar o banco (HTTP $WAKEUP_CODE)..."
            sleep 15
          fi
        done
        
        # Aguarda um pouco mais para migrations completarem
        MAX_ATTEMPTS_HEALTH=20  # 20 tentativas x 15 segundos = 5 minutos
        ATTEMPT=1
        
        while [ $ATTEMPT -le $MAX_ATTEMPTS_HEALTH ]; do
          echo "Verifica√ß√£o de sa√∫de - Tentativa $ATTEMPT/$MAX_ATTEMPTS_HEALTH..."
          sleep 15
          
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 https://$WEBAPP_URL/health || echo "000")
          
          if [ "$HTTP_CODE" = "200" ]; then
            echo "‚úÖ Health check passou! Banco de dados conectado (HTTP $HTTP_CODE)"
            break
          elif [ "$HTTP_CODE" = "000" ]; then
            echo "‚è≥ Health check ainda n√£o est√° respondendo"
          else
            echo "‚ö†Ô∏è Health check retornou HTTP $HTTP_CODE (Azure SQL Serverless pode estar inicializando)"
          fi
          
          ATTEMPT=$((ATTEMPT + 1))
        done
        
        echo "‚úÖ Verifica√ß√£o de deployment conclu√≠da!"

    - name: Clean up
      if: always()
      run: |
        rm -f deployment-package.zip
        rm -rf ${{ env.API_PROJECT_PATH }}/${{ env.OUTPUT_PATH }}

    - name: Deployment summary
      run: |
        echo "## üöÄ .NET API Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Deployment Information:" >> $GITHUB_STEP_SUMMARY
        echo "- **Environment:** production" >> $GITHUB_STEP_SUMMARY
        echo "- **Resource Group:** ${{ env.AZURE_RESOURCE_GROUP }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Web App:** ${{ steps.get-webapp-name.outputs.WEBAPP_NAME }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Build Information:" >> $GITHUB_STEP_SUMMARY
        echo "- **.NET Version:** ${{ env.DOTNET_VERSION }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Configuration:** Release" >> $GITHUB_STEP_SUMMARY
        echo "- **Package Size:** $(ls -lh deployment-package.zip 2>/dev/null | awk '{print $5}' || echo 'N/A')" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "‚úÖ Deployment completed successfully!" >> $GITHUB_STEP_SUMMARY

  api-health-check:
    name: API Health Check
    runs-on: ubuntu-latest
    needs: build-and-deploy
    if: success()
    
    steps:
    - name: Azure Login via OIDC
      uses: azure/login@v2
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    - name: Run comprehensive health checks
      run: |
        # Obt√©m a URL do Web App
        WEBAPP_URL=$(az webapp list \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --query "[?kind=='app,linux' && contains(name, 'jullius-api')].defaultHostName" \
          --output tsv | head -n 1)
        
        echo "üîç Executando health checks abrangentes em: https://$WEBAPP_URL"
        
        # Aguarda um pouco para garantir que a aplica√ß√£o esteja est√°vel
        echo "‚è≥ Aguardando 30 segundos para estabiliza√ß√£o..."
        sleep 30
        
        # Testa endpoints cr√≠ticos com retry
        endpoints=("/startup" "/wakeup-db" "/health" "/api/Card" "/api/FinancialTransaction")
        
        echo "üìä Testando endpoints principais:"
        for endpoint in "${endpoints[@]}"; do
          echo "üîó Testando: $endpoint"
          
          # Tenta 3 vezes cada endpoint
          SUCCESS=false
          for i in {1..3}; do
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 https://$WEBAPP_URL$endpoint || echo "000")
            
            if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "401" ]; then
              echo "  ‚úÖ Tentativa $i - $endpoint - HTTP $HTTP_CODE"
              SUCCESS=true
              break
            else
              echo "  ‚ö†Ô∏è Tentativa $i - $endpoint - HTTP $HTTP_CODE"
              if [ $i -lt 3 ]; then
                echo "  ‚è≥ Aguardando 10 segundos antes da pr√≥xima tentativa..."
                sleep 10
              fi
            fi
          done
          
          if [ "$SUCCESS" = "false" ]; then
            echo "  ‚ùå $endpoint falhou em todas as tentativas"
          fi
        done
        
        # Verifica o status geral da aplica√ß√£o
        echo ""
        echo "üìä Status geral da aplica√ß√£o:"
        az webapp show \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --name $(echo $WEBAPP_URL | cut -d'.' -f1) \
          --query "{name: name, state: state, availabilityState: availabilityState, lastModifiedTimeUtc: lastModifiedTimeUtc}" \
          --output table
        
        echo ""
        echo "‚úÖ Health check conclu√≠do!" 